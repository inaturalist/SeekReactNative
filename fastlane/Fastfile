# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#
require "spaceship"

fastlane_require "dotenv"

before_all do
  Dotenv.overload ".env"
end

default_platform(:android)

PROJECT_ROOT = File.expand_path("..", File.dirname(__FILE__))
ANDROID_CAMERA_PATH = File.join(PROJECT_ROOT, "android", "app", "src", "main", "assets", "camera")
IOS_CAMERA_PATH = File.join(PROJECT_ROOT, "ios")

ANDROID_BUILD_GRADLE = File.join(PROJECT_ROOT, "android", "app", "build.gradle")

VERSION = File.open( "../package.json" ) {| f | JSON.parse( f.read )["version"] }
PACKAGE_ID = CredentialsManager::AppfileConfig.try_fetch_value( :package_name )

editor_cmd = [
  ENV.fetch( "EDITOR", nil ),
  `git config core.editor`,
  `which vi`
].map {| e | e.to_s.strip }.detect {| e | !e.empty? }
if editor_cmd.nil?
  UI.abort_with_message! <<~NO_EDITOR_ERROR
    Could not find an editor, not even vi. Set the EDITOR environmental
    variable or the core.editor git config"
  NO_EDITOR_ERROR
end
editor_cmd_needs_to_wait = ( editor_cmd =~ /^code / || editor_cmd =~ /^subl / ) && !editor_cmd.include?( "-w" )
EDITOR = editor_cmd_needs_to_wait ? "#{editor_cmd} -w" : editor_cmd

def android_taxonomy_present?
  path = File.join( ANDROID_CAMERA_PATH, "taxonomy_v2_20.csv" )
  unless File.exist?( path )
    UI.abort_with_message! "Android production taxonomy file is missing at #{path}"
  end
end

def ios_taxonomy_present?
  path = File.join( IOS_CAMERA_PATH, "taxonomy_v2_20.json" )
  unless File.exist?( path )
    UI.abort_with_message! "iOS production taxonomy file is missing at #{path}"
  end
end

def android_model_present?
  path = File.join( ANDROID_CAMERA_PATH, "optimized_model_v2_20.tflite" )
  unless File.exist?( path )
    UI.abort_with_message! "Android production vision model file is missing at #{path}"
  end
end

def ios_model_present?
  path = File.join( IOS_CAMERA_PATH, "optimized_model_v2_20.mlmodel" )
  unless File.exist?( path )
    UI.abort_with_message! "iOS production vision model file is missing at #{path}"
  end
end

def required_android_files_present?
  android_taxonomy_present?
  android_model_present?
end

def required_ios_files_present?
  ios_taxonomy_present?
  ios_model_present?
end

def get_apk_path( build_number = nil )
  build_number ||= get_build_number( xcodeproj: XCODEPROJ )
  File.expand_path( File.join(
    __dir__,
    "..",
    "android",
    "app",
    "build",
    "outputs",
    "apk",
    "release",
    "#{PACKAGE_ID}-v#{VERSION}+#{build_number}-release.apk"
  ) )
end

def android_get_version_code(gradle_file: ANDROID_BUILD_GRADLE)
  path = File.expand_path(gradle_file, PROJECT_ROOT)
  UI.user_error!("Gradle file not found: #{path}") unless File.exist?(path)
  content = File.read(path)
  match = content.match(/versionCode\s+(\d+)/)
  UI.user_error!("Could not find versionCode in #{path}") unless match
  match[1].to_i
end

def android_get_version_name(gradle_file: ANDROID_BUILD_GRADLE)
  path = File.expand_path(gradle_file, PROJECT_ROOT)
  UI.user_error!("Gradle file not found: #{path}") unless File.exist?(path)
  content = File.read(path)
  match = content.match(/versionName\s+"([^"]+)"/)
  UI.user_error!("Could not find versionName in #{path}") unless match
  match[1]
end

platform :ios do
  desc "Distributes a beta version of Seek on TestFlight"
  lane :beta do
    required_ios_files_present?
    # xcode_select("/Applications/Xcode-beta.app")
    get_certificates(username: ENV["USERNAME"]) # invokes cert
    get_provisioning_profile(username: ENV["USERNAME"],
                         app_identifier: ENV["APPLE_ID"]) # invokes sigh
    build_app(scheme: "Seek",
           workspace: "ios/Seek.xcworkspace",
           include_bitcode: false)
    upload_to_testflight(username: ENV["USERNAME"],
                        groups: [
                          "iNat Staff"
                        ])
    app_store_build_number(live: false, username: ENV["USERNAME"], app_identifier: ENV["APPLE_ID"])
    slack(
      message: "Seek iOS beta successfully deployed!",
      success: true,
      slack_url: ENV["SLACK_WEBHOOK"],
      default_payloads: [:lane, :test_result, :git_branch, :last_git_commit_hash],
      attachment_properties: {
           fields: [
               {
                  title: "Version Number",
                  value: lane_context[SharedValues::LATEST_VERSION]
               },
               {
                 title: "Build Number",
                 value: lane_context[SharedValues::LATEST_BUILD_NUMBER]
               }
           ]
       })
  end

  lane :release do
    deliver(
      username: ENV["USERNAME"],
      build_number: lane_context[SharedValues::LATEST_BUILD_NUMBER],
      submit_for_review: true,
      automatic_release: false,
      force: false, # Skip HTMl report verification
      skip_metadata: false, # make sure Deliverfile has latest release notes
      skip_screenshots: true,
      skip_binary_upload: true,
      submission_information: {
        add_id_info_uses_idfa: false
      },
      precheck_include_in_app_purchases: false
    )
    slack(
      message: "Successfully uploaded a new App Store release build",
      success: true,
      slack_url: ENV["SLACK_WEBHOOK"],
      default_payloads: [:lane, :test_result, :git_branch, :last_git_commit_hash],
      attachment_properties: {
           fields: [
               {
                  title: "Version Number",
                  value: lane_context[SharedValues::LATEST_VERSION]
               },
               {
                 title: "Build Number",
                 value: lane_context[SharedValues::LATEST_BUILD_NUMBER]
               }
           ]
       })
  end

  lane :download_app_store_reviews do
    desc "Download App Store reviews and save them to a file"

    UI.message "Logging into App Store Connect..."

    # Explicitly login with credentials
    Spaceship::Tunes.login( ENV["USERNAME"] )
    Spaceship::Tunes.select_team( team_id: ENV["TEAM_ID"], team_name: nil )

    # Select the app using the bundle ID from the Appfile
    UI.message "Finding app with bundle ID: #{ENV["APPLE_ID"]}"
    app = Spaceship::Tunes::Application.find( ENV["APPLE_ID"] )

    unless app
      UI.abort_with_message! "Could not find app with bundle ID: #{ENV["APPLE_ID"]}"
    end

    # Fetch reviews
    UI.message "Fetching reviews for #{app.name}..."
    reviews = app.ratings.reviews

    # Create an array to hold processed reviews
    processed_reviews = []
    reviews.each do | review |
      # Convert review object to a hash with the fields you want
      processed_review = {
        rating: review.rating.to_i,
        title: review.title,
        review_content: review.review,
        nickname: review.nickname,
        country: review.store_front,
        last_modified: review.last_modified,
        edited: review.edited,
        responded: review.responded?,
        developer_response: review.developer_response.response
      }
      processed_reviews << processed_review
    end

    # Save reviews to a JSON file
    output_file = "app_store_reviews.json"
    File.write( output_file, JSON.pretty_generate( processed_reviews ) )

    UI.success "Downloaded #{reviews.count} reviews to #{output_file}"
  end
end

platform :android do
  desc "Upload description to Google Play"
  lane :upload_metadata do
    required_android_files_present?
    validate_play_store_json_key(json_key: ENV["JSON_KEY_ANDROID"])
    upload_to_play_store(
      track: "beta",
      package_name: ENV["PACKAGE_NAME"],
      version_code: android_get_version_code(gradle_file: "android/app/build.gradle"),
      skip_upload_apk: true,
      skip_upload_aab: true,
      skip_upload_changelogs: true,
    )
  end

  lane :build_apk do
  desc "Build apk for github releases"
    build_number = android_get_version_code( )
    # Build APK. This should write
    # android/app/build/outputs/apk/release/PACKAGE_ID-vVERSION_NAME+VERSION_CODE-release.apk
    apk_path = get_apk_path( build_number )
    if File.exist?( apk_path )
      UI.important "APK already exists at #{apk_path}"
    else
      gradle( task: "build", project_dir: "android", flags: "-x lint" )
    end
    unless File.exist?( apk_path )
      UI.abort_with_message! "Failed to create APK at #{apk_path}"
    end
  end

 desc "Distributes an Android bundle to the Play Store internal beta track"
 lane :internal do
    required_android_files_present?
    validate_play_store_json_key(json_key: ENV["JSON_KEY_ANDROID"])
    gradle(task: "bundle", build_type: "Release", project_dir: "android")
    upload_to_play_store(
      track: "internal",
      package_name: ENV["PACKAGE_NAME"],
      version_code: android_get_version_code(gradle_file: "android/app/build.gradle"),
      skip_upload_apk: true,
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      )
 end

 desc "Distributes an Android bundle to the Play Store beta track"
 lane :beta do
    required_android_files_present?
    validate_play_store_json_key(json_key: ENV["JSON_KEY_ANDROID"])
    gradle(task: "bundle", build_type: "Release", project_dir: "android")
    upload_to_play_store(
      track: "beta",
      package_name: ENV["PACKAGE_NAME"],
      version_code: android_get_version_code(gradle_file: "android/app/build.gradle"),
      skip_upload_apk: true,
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      )
    slack(
     message: "Seek Android beta successfully deployed!",
     success: true,
     slack_url: ENV["SLACK_WEBHOOK"],
     default_payloads: [:lane, :test_result, :git_branch, :last_git_commit_hash],
     attachment_properties: {
          fields: [
              {
                 title: "Version Number",
                 value: android_get_version_name(gradle_file: "android/app/build.gradle")
              },
              {
                title: "Build Number",
                value: android_get_version_code(gradle_file: "android/app/build.gradle")
              }
          ]
      })
 end

 desc "Build debug and test APK for screenshots"
  lane :build_for_screengrab do
    build_android_app(
      task: "assemble",
      build_type: "Debug"
    )
    build_android_app(
      task: "assemble",
      build_type: "AndroidTest"
    )
  end

end

def prompt_for_release_notes( options = {} )
  instructions = options[:instructions] || ""
  # Get release notes
  # Bit silly but takes advantage of existing syntax highlighting
  fname = "COMMIT_EDITMSG"
  File.open( fname, "w" ) do | f |
    f << instructions
  end
  system "#{EDITOR} #{fname}", exception: true
  release_notes = ""
  File.readlines( fname ).each do | line |
    release_notes += line unless line[0] == "#"
  end
  release_notes.strip!
  FileUtils.rm( fname )
  if release_notes.strip.empty?
    if options[:reset_git_repo_on_fail]
      reset_git_repo skip_clean: true
    end
    UI.abort_with_message! "You gotta enter release notes!"
  end
  if release_notes.strip.length > 500
    if options[:reset_git_repo_on_fail]
      reset_git_repo skip_clean: true
    end
    UI.abort_with_message! "Release notes must be 500 characters or less"
  end
  # Return the release notes
  release_notes
end

lane :github_release do | options |
  desc "Make github release for the latest tag and make builds"
  last_tag = last_git_tag
  if last_tag.nil? || last_tag.empty?
    UI.abort_with_message! "No tags have been added yet. Try starting with `fastlane tag`"
  end
  original_branch = git_branch
  system "git checkout #{last_tag}", exception: true
  build_number = android_get_version_code( )
  if build_number.to_s != last_tag.split( "-" ).last
    UI.abort_with_message! <<~MSG
      The last tag doesn't match the current build number. Either make a new
      tag or check out the tag before releasing.
    MSG
  end

  last_tag = last_git_tag
  changes = changelog_from_git_commits( pretty: "# * %h %s (%an, %ai)" )

  # Prompt for release notes
  instructions = <<~INSTRUCTIONS


    # Enter notes about what's new in #{last_tag}. Lines beginning with # will be ignored.
    # Keep notes within the 500 character limit required by Google Play.
    #
    # Here's what changed since the last tag:
    #{changes}
  INSTRUCTIONS
  # At the moment we are not bothered about translating those into other languages
  release_notes = prompt_for_release_notes( instructions: instructions, reset_git_repo_on_fail: true )

  apk_path = File.expand_path( get_apk_path( build_number ) )
  if File.exist?( apk_path )
    UI.success "Found APK at #{apk_path}"
  else
    UI.abort_with_message! "Failed to find APK at #{apk_path}"
  end

  github_release = get_github_release(
    url: "inaturalist/SeekReactNative",
    version: last_tag,
    api_token: ENV.fetch( "GITHUB_TOKEN", nil )
  )
  if github_release
    UI.important "Release already exists at #{github_release['url']}. You need to manually upload any missing assets."
  else
    set_github_release(
      repository_name: "inaturalist/SeekReactNative",
      api_token: ENV.fetch( "GITHUB_TOKEN", nil ),
      name: last_tag,
      tag_name: last_tag,
      description: release_notes,
      # This is really just a fallback in case last_tag isn't really a tag
      commitish: "main",
      upload_assets: [apk_path],
      is_prerelease: true
    )
  end
  system "git checkout #{original_branch}", exception: true
end